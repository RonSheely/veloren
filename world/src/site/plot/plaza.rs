use super::*;
use crate::{ColumnSample, Land, util::RandomField};
use common::terrain::{Block, BlockKind};
use enum_map::EnumMap;
use rand::prelude::*;
use strum::IntoEnumIterator;
use vek::*;

#[derive(Default)]
struct CornerMeta {
    water_alt: i32,
    alt: i32,
}

impl CornerMeta {
    fn water(&self) -> bool { self.alt < self.water_alt }
}

/// Represents house data generated by the `generate()` method
pub struct Plaza {
    pub aabr: Aabr<i32>,
    pub kind: RoadKind,
    corner_meta: EnumMap<Dir, CornerMeta>,
    pub hard_alt: Option<i32>,
    dir: Dir,
}

impl Plaza {
    pub fn generate(
        tile_aabr: Aabr<i32>,
        kind: RoadKind,
        site: &Site,
        land: &Land,
        index: IndexRef,
    ) -> Self {
        let aabr = Aabr {
            min: site.tile_wpos(tile_aabr.min),
            max: site.tile_wpos(tile_aabr.max),
        };
        let mut iaabr = aabr;
        iaabr.max -= 1;

        let get_corner_meta = |wpos| {
            land.column_sample(wpos, index)
                .map(|col| CornerMeta {
                    water_alt: col.water_level as i32,
                    alt: col.alt as i32,
                })
                .unwrap_or_default()
        };

        let center = get_corner_meta(iaabr.center());

        let corner_meta: EnumMap<Dir, CornerMeta> = Dir::iter()
            .map(|d| {
                let o = d.rotated_cw();
                let pos = d.select_aabr_with(iaabr, o.select_aabr(iaabr));
                (d, get_corner_meta(pos))
            })
            .collect();

        let any_water = center.water() || corner_meta.values().any(|c| c.water());

        Self {
            aabr,
            kind,
            corner_meta,
            hard_alt: if any_water {
                Some((land.get_alt_approx(aabr.center()) as i32).max(center.water_alt + 1))
            } else {
                None
            },
            dir: *RandomField::new(51)
                .choose(aabr.center().with_z(center.alt), &Dir::ALL)
                .expect("Dir::ALL has len 4"),
        }
    }
}

impl Structure for Plaza {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_plaza\0";

    #[cfg_attr(feature = "be-dyn-lib", unsafe(export_name = "render_plaza"))]
    fn render_inner(&self, site: &Site, land: &Land, painter: &Painter) {
        if let Some(alt) = self.hard_alt {
            let wood_corner = Fill::Brick(BlockKind::Wood, Rgb::new(86, 50, 50), 10);
            let bounds = Aabb {
                min: self.aabr.min.with_z(alt),
                max: self.aabr.max.with_z(alt + 1),
            };
            painter.aabb(bounds).fill(wood_corner.clone());
            let mut iaabr = self.aabr;
            let hsize = iaabr.half_size();
            iaabr.min += 1;
            iaabr.max -= 2;
            for (d, meta) in self.corner_meta.iter() {
                let o = d.rotated_cw();

                let corner = d.select_aabr_with(iaabr, o.select_aabr(iaabr));

                painter
                    .column(corner, meta.alt - 5..alt)
                    .fill(wood_corner.clone());

                for (dir, index) in [(d, d.rotated_ccw()), (o, o)] {
                    let dp = -dir;
                    let min_alt = meta.alt.min(self.corner_meta[d.relative_to(index)].alt);
                    for i in (0..dp.select(hsize)).step_by(8) {
                        let p = corner + dp.to_vec2() * i;
                        painter
                            .column(p, min_alt - 5..alt)
                            .fill(wood_corner.clone());
                    }
                }
            }
        }

        let tile_aabr = Aabr {
            min: site.wpos_tile_pos(self.aabr.min),
            max: site.wpos_tile_pos(self.aabr.max) - 1,
        };

        for dir in Dir::iter() {
            let orth = dir.orthogonal();

            for i in (orth.select(tile_aabr.min) + 1)..orth.select(tile_aabr.max) {
                let tpos = dir.select_aabr_with(tile_aabr, i);
                if (tpos.x + tpos.y) % 3 != 0 {
                    continue;
                }

                if site.tiles.get(tpos + dir.to_vec2()).is_empty() {
                    let wpos = site.tile_center_wpos(tpos);

                    // TODO: Not sure if this is always correct
                    let alt = self
                        .hard_alt
                        .unwrap_or_else(|| land.get_alt_approx(wpos) as i32)
                        + 1;
                    let wpos = wpos.with_z(alt);
                    self.kind.place_light(wpos, -dir, painter);
                }
            }
        }

        let rng = &mut thread_rng();
        if rng.gen_bool(0.05) {
            let spec = [
                "common.entity.wild.peaceful.cat",
                "common.entity.wild.peaceful.dog",
            ]
            .choose(rng)
            .unwrap();
            let center = self.aabr.center();
            painter.spawn(
                EntityInfo::at(
                    Vec3::new(center.x, center.y, land.get_alt_approx(center) as i32).as_(),
                )
                .with_asset_expect(spec, rng, None)
                .with_alignment(Alignment::Tame),
            );
        }
    }

    fn rel_terrain_offset(&self, col: &ColumnSample) -> i32 { col.riverless_alt as i32 }

    fn terrain_surface_at<R: Rng>(
        &self,
        wpos: Vec2<i32>,
        old: Block,
        _rng: &mut R,
        col: &ColumnSample,
        z_off: i32,
        _site: &Site,
    ) -> Option<Block> {
        let z = self.rel_terrain_offset(col) + z_off;
        if col.water_level > col.alt || self.hard_alt.is_some_and(|alt| z < alt) {
            return None;
        };
        if z_off <= 0 {
            let block = self.kind.block(col, wpos.with_z(z), self.dir);
            if old.is_filled() {
                if old.is_terrain() { Some(block) } else { None }
            } else if self.hard_alt.is_none() {
                Some(block)
            } else {
                None
            }
        } else if old.is_fluid() || old.kind() == BlockKind::Snow || old.is_terrain() {
            Some(old.into_vacant())
        } else {
            None
        }
    }
}
