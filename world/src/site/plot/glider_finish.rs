use super::*;
use crate::Land;
use common::terrain::BlockKind;
use rand::prelude::*;
use vek::*;

/// Represents data generated by the `generate()` method
pub struct GliderFinish {
    /// Location of center
    center: Vec2<i32>,
    /// Approximate altitude
    pub(crate) alt: i32,
    /// Tile side length for checkerboard surface
    tile_width: i32,
    /// Distance from the center of the checkerboard platform to the edge.
    radius: i32,
}

impl GliderFinish {
    pub fn generate(land: &Land, _rng: &mut impl Rng, _site: &Site, wpos: Vec2<i32>) -> Self {
        Self {
            center: wpos,
            alt: land.get_alt_approx(wpos) as i32,
            tile_width: 2,
            radius: 10,
        }
    }
}

impl Structure for GliderFinish {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_glider_finish\0";

    #[cfg_attr(feature = "be-dyn-lib", unsafe(export_name = "render_glider_finish"))]
    fn render_inner(&self, _site: &Site, _land: &Land, painter: &Painter) {
        let red = Fill::Brick(BlockKind::Wood, Rgb::new(200, 0, 0), 24);
        let green = Fill::Brick(BlockKind::Wood, Rgb::new(0, 200, 0), 24);
        let white = Fill::Brick(BlockKind::GlowingRock, Rgb::new(200, 200, 200), 24);
        let black = Fill::Brick(BlockKind::Wood, Rgb::new(0, 0, 0), 24);
        let wood = Fill::Brick(BlockKind::Wood, Rgb::new(40, 30, 20), 24);

        let base = self.alt + 6;

        // Base
        let foundation_0 = painter.aabb(Aabb {
            min: Vec2::new(
                self.center.x - self.radius - 4,
                self.center.y - self.radius - 4,
            )
            .with_z(base - 50),
            max: Vec2::new(
                self.center.x + self.radius + 4,
                self.center.y + self.radius + 4,
            )
            .with_z(base - 2),
        });
        let foundation_1 = painter.aabb(Aabb {
            min: Vec2::new(
                self.center.x - self.radius - 3,
                self.center.y - self.radius - 3,
            )
            .with_z(base - 2),
            max: Vec2::new(
                self.center.x + self.radius + 3,
                self.center.y + self.radius + 3,
            )
            .with_z(base - 1),
        });
        let foundation_2 = painter.aabb(Aabb {
            min: Vec2::new(
                self.center.x - self.radius - 2,
                self.center.y - self.radius - 2,
            )
            .with_z(base - 1),
            max: Vec2::new(
                self.center.x + self.radius + 2,
                self.center.y + self.radius + 2,
            )
            .with_z(base),
        });
        let platform = painter.aabb(Aabb {
            min: Vec2::new(
                self.center.x - self.radius - 1,
                self.center.y - self.radius - 1,
            )
            .with_z(base),
            max: Vec2::new(
                self.center.x + self.radius + 1,
                self.center.y + self.radius + 1,
            )
            .with_z(base + 1),
        });
        let above_platform = painter.aabb(Aabb {
            min: Vec2::new(
                self.center.x - self.radius - 4,
                self.center.y - self.radius - 4,
            )
            .with_z(base - 2),
            max: Vec2::new(
                self.center.x + self.radius + 4,
                self.center.y + self.radius + 4,
            )
            .with_z(base + 30),
        });

        // Checkerboard pattern
        let mut white_fills = Vec::new();
        let mut black_fills = Vec::new();
        for i in 0..self.radius * 2 {
            for j in 0..self.radius * 2 {
                let white_tile_start = (i % 4 == 0 && j % 4 == 0) || (i % 4 == 2 && j % 4 == 2);
                let black_tile_start = (i % 4 == 0 && j % 4 == 2) || (i % 4 == 2 && j % 4 == 0);
                if white_tile_start {
                    let tile_start = Vec2::new(
                        self.center.x - self.radius + i,
                        self.center.y - self.radius + j,
                    );
                    let tile_end = tile_start + self.tile_width;
                    let white_tile = painter.aabb(Aabb {
                        min: tile_start.with_z(base),
                        max: tile_end.with_z(base + 1),
                    });
                    white_fills.push(white_tile);
                } else if black_tile_start {
                    let tile_start = Vec2::new(
                        self.center.x - self.radius + i,
                        self.center.y - self.radius + j,
                    );
                    let tile_end = tile_start + self.tile_width;
                    let black_tile = painter.aabb(Aabb {
                        min: tile_start.with_z(base),
                        max: tile_end.with_z(base + 1),
                    });
                    black_fills.push(black_tile);
                }
            }
        }

        let green_fills = [platform];
        let red_fills = [foundation_2];
        let wood_fills = [foundation_0, foundation_1];
        let clears = [above_platform];

        let fills = [
            (&clears as &[_], None),
            (&wood_fills, Some(wood)),
            (&red_fills, Some(red)),
            (&green_fills, Some(green)),
            (&black_fills, Some(black)),
            (&white_fills, Some(white)),
        ];

        for (primitives, fill_color_maybe) in fills {
            for prim in primitives {
                if let Some(fill_color) = &fill_color_maybe {
                    prim.fill(fill_color.clone());
                } else {
                    prim.clear();
                }
            }
        }
    }
}
