use super::*;
use crate::{
    Land,
    site::{generation::PrimitiveTransform, util::Dir},
};
use common::terrain::BlockKind;
use rand::prelude::*;
use vek::*;

/// Represents house data generated by the `generate()` method
pub struct GliderPlatform {
    /// Location of center of ring post
    center: Vec2<i32>,
    direction: Dir,
    /// Approximate altitude of the door tile
    pub(crate) alt: i32,
}

impl GliderPlatform {
    pub fn generate(
        land: &Land,
        _rng: &mut impl Rng,
        _site: &Site,
        wpos: Vec2<i32>,
        direction: Dir,
    ) -> Self {
        // FIXME this should be fed into this function
        Self {
            center: wpos,
            direction,
            alt: land.get_alt_approx(wpos) as i32,
        }
    }
}

impl Structure for GliderPlatform {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_glider_platform\0";

    #[cfg_attr(feature = "be-dyn-lib", unsafe(export_name = "render_glider_platform"))]
    fn render_inner(&self, _site: &Site, _land: &Land, painter: &Painter) {
        let rotate_turns = match self.direction {
            Dir::X => 0,
            Dir::Y => 1,
            Dir::NegX => 2,
            Dir::NegY => 3,
        };
        let rotation_center = Vec3::new(self.center.x, self.center.y, self.alt);

        let white = Fill::Brick(BlockKind::GlowingRock, Rgb::new(200, 200, 200), 24);
        let wood = Fill::Brick(BlockKind::Wood, Rgb::new(55, 25, 8), 24);

        let base = self.alt + 8;
        // Base
        let above_platform = painter.aabb(Aabb {
            min: Vec2::new(self.center.x - 10, self.center.y - 4).with_z(base + 1),
            max: Vec2::new(self.center.x + 15, self.center.y + 5).with_z(base + 10),
        });

        let platform = painter.aabb(Aabb {
            min: Vec2::new(self.center.x - 10, self.center.y - 4).with_z(base),
            max: Vec2::new(self.center.x + 15, self.center.y + 5).with_z(base + 1),
        });
        let stairs = painter.plane(
            Aabr {
                min: Vec2::new(self.center.x - 30, self.center.y - 4),
                max: Vec2::new(self.center.x - 10, self.center.y + 5),
            },
            Vec3::new(self.center.x - 30, self.center.y - 4, base - 20),
            Vec2::new(1.0, 0.0),
        );
        let leg_0 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x + 14, self.center.y - 4).with_z(base - 50),
            max: Vec2::new(self.center.x + 15, self.center.y - 3).with_z(base),
        });
        let leg_1 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x - 10, self.center.y - 4).with_z(base - 50),
            max: Vec2::new(self.center.x - 9, self.center.y - 3).with_z(base),
        });
        let leg_2 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x + 14, self.center.y + 4).with_z(base - 50),
            max: Vec2::new(self.center.x + 15, self.center.y + 5).with_z(base),
        });
        let leg_3 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x - 10, self.center.y + 4).with_z(base - 50),
            max: Vec2::new(self.center.x - 9, self.center.y + 5).with_z(base),
        });
        let arrow_shaft = painter.aabb(Aabb {
            min: Vec2::new(self.center.x + 8, self.center.y + 0).with_z(base),
            max: Vec2::new(self.center.x + 14, self.center.y + 1).with_z(base + 1),
        });
        let arrow_head_0 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x + 11, self.center.y - 2).with_z(base),
            max: Vec2::new(self.center.x + 12, self.center.y + 3).with_z(base + 1),
        });
        let arrow_head_1 = painter.aabb(Aabb {
            min: Vec2::new(self.center.x + 12, self.center.y - 1).with_z(base),
            max: Vec2::new(self.center.x + 13, self.center.y + 2).with_z(base + 1),
        });

        let clears = [above_platform];
        let wood_fills = [platform, stairs, leg_0, leg_1, leg_2, leg_3];
        let white_fills = [arrow_shaft, arrow_head_0, arrow_head_1];

        let fills = [
            (&wood_fills as &[_], Some(wood)),
            (&white_fills, Some(white.clone())),
            (&clears, None),
        ];
        for (primitives, fill_color_maybe) in fills {
            for prim in primitives {
                if let Some(fill_color) = &fill_color_maybe {
                    prim.rotate_z_90_about(rotate_turns, rotation_center)
                        .fill(fill_color.clone());
                } else {
                    prim.rotate_z_90_about(rotate_turns, rotation_center)
                        .clear();
                }
            }
        }
    }
}
