use super::*;
use crate::{
    Land,
    site::generation::{PrimitiveTransform, place_circular},
    util::{CARDINALS, RandomField, Sampler, within_distance},
};
use common::{
    generation::SpecialEntity,
    terrain::{BlockKind, SpriteKind},
};
use rand::prelude::*;
use std::sync::Arc;
use vek::*;

/// Represents house data generated by the `generate()` method
pub struct CoastalAirshipDock {
    /// Tile position of the door tile
    pub door_tile: Vec2<i32>,
    /// Approximate altitude of the door tile
    pub(crate) alt: i32,
    base: i32,
    pub center: Vec2<i32>,
    size: i32,
    bldg_height: i32,
    diameter: i32,
    pub docking_positions: Vec<Vec3<i32>>,
}

impl CoastalAirshipDock {
    pub fn generate(
        land: &Land,
        _rng: &mut impl Rng,
        site: &Site,
        door_tile: Vec2<i32>,
        door_dir: Vec2<i32>,
        tile_aabr: Aabr<i32>,
        alt: Option<i32>,
    ) -> Self {
        let door_tile_pos = site.tile_center_wpos(door_tile);
        let bounds = Aabr {
            min: site.tile_wpos(tile_aabr.min),
            max: site.tile_wpos(tile_aabr.max),
        };
        let diameter = (bounds.max.x - bounds.min.x).min(bounds.max.y - bounds.min.y);
        let alt = alt.unwrap_or_else(|| {
            land.get_alt_approx(site.tile_center_wpos(door_tile + door_dir)) as i32
        }) + 2;
        let size = 20;
        let bldg_height = 12;
        let base = alt + 1;
        let center = bounds.center();
        let top_floor = base + (bldg_height * 6) - 3;
        let docking_positions = CARDINALS
            .iter()
            .map(|dir| (center + dir * 31).with_z(top_floor - 1))
            .collect::<Vec<_>>();
        Self {
            door_tile: door_tile_pos,
            alt,
            base,
            center,
            size,
            bldg_height,
            diameter,
            docking_positions,
        }
    }

    pub fn spawn_rules(&self, wpos: Vec2<i32>) -> SpawnRules {
        SpawnRules {
            trees: {
                // dock is 5 tiles = 30 blocks in radius
                // airships are 39 blocks wide.
                // Tree can be up to 20 blocks in radius.
                // Don't allow trees within 30 + 39 + 20 = 89 blocks of the dock center
                const AIRSHIP_MIN_TREE_DIST2: i32 = 89;
                !within_distance(wpos, self.center, AIRSHIP_MIN_TREE_DIST2)
            },
            waypoints: false,
            ..SpawnRules::default()
        }
    }
}

impl Structure for CoastalAirshipDock {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_coastal_airship_dock\0";

    #[cfg_attr(
        feature = "be-dyn-lib",
        unsafe(export_name = "render_coastal_airship_dock")
    )]
    fn render_inner(&self, _site: &Site, _land: &Land, painter: &Painter) {
        let base = self.base;
        let center = self.center;
        let white = Fill::Sampling(Arc::new(|center| {
            Some(match (RandomField::new(0).get(center)) % 37 {
                0..=8 => Block::new(BlockKind::Rock, Rgb::new(251, 251, 227)),
                9..=17 => Block::new(BlockKind::Rock, Rgb::new(245, 245, 229)),
                18..=26 => Block::new(BlockKind::Rock, Rgb::new(250, 243, 221)),
                27..=35 => Block::new(BlockKind::Rock, Rgb::new(240, 240, 230)),
                _ => Block::new(BlockKind::Rock, Rgb::new(255, 244, 193)),
            })
        }));
        let blue_broken = Fill::Sampling(Arc::new(|center| {
            Some(match (RandomField::new(0).get(center)) % 20 {
                0 => Block::new(BlockKind::Rock, Rgb::new(30, 187, 235)),
                _ => Block::new(BlockKind::Rock, Rgb::new(11, 146, 187)),
            })
        }));

        let length = self.diameter / 2;
        let width = (self.diameter / 2) - 1;
        let height = 15;
        // fence, blue gates
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - length - 6, center.y - width - 6).with_z(base - 2),
                max: Vec2::new(center.x + length + 7, center.y + width + 7).with_z(base - 1),
            })
            .fill(blue_broken.clone());

        for dir in CARDINALS {
            let frame_pos = Vec2::new(
                center.x + dir.x * (length + 5),
                center.y + dir.y * (width + 5),
            );
            painter
                .line(center.with_z(base - 1), frame_pos.with_z(base - 1), 3.0)
                .fill(blue_broken.clone());
        }
        // foundation
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - length - 6, center.y - width - 6).with_z(base - height),
                max: Vec2::new(center.x + length + 7, center.y + width + 7).with_z(base - 2),
            })
            .fill(white.clone());
        for f in 0..8 {
            painter
                .aabb(Aabb {
                    min: Vec2::new(center.x - length - 7 - f, center.y - width - 7 - f)
                        .with_z(base - 3 - f),
                    max: Vec2::new(center.x + length + 8 + f, center.y + width + 8 + f)
                        .with_z(base - 2 - f),
                })
                .fill(white.clone());
        }
        // clear yard
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - length - 5, center.y - width - 5).with_z(base - 2),
                max: Vec2::new(center.x + length + 6, center.y + width + 6).with_z(base + height),
            })
            .clear();
        // clear entries
        for dir in CARDINALS {
            let clear_pos = Vec2::new(
                center.x + dir.x * (length + 7),
                center.y + dir.y * (width + 7),
            );
            painter
                .line(center.with_z(base - 1), clear_pos.with_z(base - 1), 2.0)
                .clear();
        }

        // rooms
        let size = self.size;
        let room_offset = size / 6;
        let bldg_height = self.bldg_height;
        let tower_height = (bldg_height as f32 * 1.5).round() as i32;
        for r in 0..=4 {
            let bldg_size = size - (room_offset * r);
            let bldg_base = base + ((bldg_height + 2) * r);
            let level_height = bldg_base + bldg_height;
            if r == 4 {
                // Center platform
                painter
                    .cylinder_with_radius(
                        center.with_z(level_height - 1),
                        (bldg_size + 5) as f32,
                        1.0,
                    )
                    .fill(white.clone());
                // blue walls
                painter
                    .cylinder_with_radius(center.with_z(level_height), (bldg_size + 5) as f32, 1.0)
                    .fill(blue_broken.clone());

                // Agent Desk

                // Agent booth back wall, less than ~ 1 quadrant
                let agent_booth_mask = painter.aabb(Aabb {
                    min: (Vec2::new(center.x - (bldg_size - 4), center.y + (bldg_size - 4)))
                        .with_z(level_height),
                    max: (Vec2::new(center.x - (bldg_size + 5), center.y + (bldg_size + 5)))
                        .with_z(level_height + 2),
                });
                painter
                    .cylinder_with_radius(center.with_z(level_height), (bldg_size + 5) as f32, 2.0)
                    .intersect(agent_booth_mask)
                    .fill(blue_broken.clone());

                // Clear top
                painter
                    .cylinder_with_radius(center.with_z(level_height), (bldg_size + 4) as f32, 2.0)
                    .clear();

                // Agent booth front wall
                painter
                    .cylinder_with_radius(center.with_z(level_height), (bldg_size + 2) as f32, 1.0)
                    .intersect(agent_booth_mask)
                    .fill(blue_broken.clone());
                // Clear excess Agent booth front wall
                painter
                    .cylinder_with_radius(center.with_z(level_height), (bldg_size + 1) as f32, 1.0)
                    .intersect(agent_booth_mask)
                    .clear();
                // Agent booth connecting walls
                painter
                    .line(
                        Vec2::new(center.x - (bldg_size + 3), center.y + (bldg_size - 5))
                            .with_z(level_height),
                        Vec2::new(center.x - (bldg_size + 2), center.y + (bldg_size - 5))
                            .with_z(level_height),
                        0.5,
                    )
                    .fill(blue_broken.clone());
                painter
                    .line(
                        Vec2::new(center.x - (bldg_size - 4), center.y + (bldg_size + 1))
                            .with_z(level_height),
                        Vec2::new(center.x - (bldg_size - 4), center.y + (bldg_size + 2))
                            .with_z(level_height),
                        0.5,
                    )
                    .fill(blue_broken.clone());

                // Clear the gangways
                painter
                    .aabb(Aabb {
                        min: Vec2::new(center.x - 3, center.y + bldg_size * 2).with_z(level_height),
                        max: Vec2::new(center.x + 3, center.y - (bldg_size * 2))
                            .with_z(level_height + 1),
                    })
                    .clear();
                painter
                    .aabb(Aabb {
                        min: Vec2::new(center.x - bldg_size * 2, center.y - 3).with_z(level_height),
                        max: Vec2::new(center.x + bldg_size * 2, center.y + 3)
                            .with_z(level_height + 1),
                    })
                    .clear();

                // Cable Tower
                painter
                    .cylinder_with_radius(center.with_z(level_height), 1.0, tower_height as f32)
                    .fill(white.clone());
                painter
                    .cone_with_radius(center.with_z(level_height + tower_height), 4.0, 3.0)
                    .fill(white.clone());

                let glowing =
                    Fill::Block(Block::new(BlockKind::GlowingRock, Rgb::new(30, 187, 235)));
                painter
                    .sphere(Aabb {
                        min: (center - 4).with_z(level_height + tower_height + 3),
                        max: (center + 4).with_z(level_height + tower_height + 11),
                    })
                    .fill(glowing.clone());

                // cargo
                let cargo_pos = Vec2::new(center.x, center.y + 5);
                for dir in CARDINALS.iter() {
                    let sprite_pos = cargo_pos + dir;
                    let rows = 1 + (RandomField::new(0).get(sprite_pos.with_z(base)) % 3) as i32;
                    for r in 0..rows {
                        painter
                            .aabb(Aabb {
                                min: (sprite_pos).with_z(level_height + r),
                                max: (sprite_pos + 1).with_z(level_height + 1 + r),
                            })
                            .fill(Fill::Block(Block::air(
                                match (RandomField::new(0).get(sprite_pos.with_z(base + r)) % 2)
                                    as i32
                                {
                                    0 => SpriteKind::Barrel,
                                    _ => SpriteKind::CrateBlock,
                                },
                            )));
                        if r > 1 {
                            painter.owned_resource_sprite(
                                sprite_pos.with_z(level_height + 1 + r),
                                SpriteKind::Crate,
                                0,
                            );
                        }
                    }

                    // gangway and dock
                    let dock_pos = center + dir * 27;
                    let rotation = -f32::atan2(dir.x as f32, dir.y as f32);

                    painter
                        .aabb(Aabb {
                            min: Vec2::new(center.x - 4, center.y + bldg_size + 1)
                                .with_z(level_height - 1),
                            max: Vec2::new(center.x + 4, center.y + 27).with_z(level_height),
                        })
                        .rotate_about(Mat3::rotation_z(rotation).as_(), center.with_z(base))
                        .fill(white.clone());
                    painter
                        .cylinder_with_radius(dock_pos.with_z(level_height), 5.0, 1.0)
                        .fill(blue_broken.clone());
                    painter
                        .cylinder_with_radius(dock_pos.with_z(level_height - 1), 4.0, 2.0)
                        .fill(white.clone());

                    // suspension cables
                    painter
                        .line(
                            Vec2::new(center.x - 4, center.y + 2)
                                .with_z(level_height + tower_height),
                            Vec2::new(center.x - 4, center.y + tower_height + 2)
                                .with_z(level_height),
                            0.75,
                        )
                        .rotate_about(Mat3::rotation_z(rotation).as_(), center.with_z(base))
                        .fill(white.clone());
                    painter
                        .line(
                            Vec2::new(center.x + 3, center.y + 2)
                                .with_z(level_height + tower_height),
                            Vec2::new(center.x + 3, center.y + tower_height + 2)
                                .with_z(level_height),
                            0.75,
                        )
                        .rotate_about(Mat3::rotation_z(rotation).as_(), center.with_z(base))
                        .fill(white.clone());
                }
                // campfire
                let campfire_pos = (center + Vec2::new(0, -3)).with_z(level_height);
                painter.spawn(
                    EntityInfo::at(campfire_pos.map(|e| e as f32 + 0.5))
                        .into_special(SpecialEntity::Waypoint),
                );
            }
            painter
                .cylinder(Aabb {
                    min: (center - bldg_size).with_z(bldg_base - 2),
                    max: (center + bldg_size).with_z(level_height),
                })
                .fill(white.clone());
        }
        for r in 0..=4 {
            let bldg_size = size - (room_offset * r);
            let bldg_base = base + ((bldg_height + 2) * r);

            let step_positions = place_circular(center, (bldg_size - 1) as f32, 14);
            for (s, step_pos) in step_positions.enumerate() {
                let step_size = (size / 3) - r;

                painter
                    .cylinder(Aabb {
                        min: (step_pos - step_size).with_z(bldg_base - 2 + s as i32),
                        max: (step_pos + step_size).with_z(bldg_base + 4 + s as i32),
                    })
                    .clear();
                painter
                    .cylinder(Aabb {
                        min: (step_pos - step_size).with_z(bldg_base - 3 + s as i32),
                        max: (step_pos + step_size).with_z(bldg_base - 2 + s as i32),
                    })
                    .fill(blue_broken.clone());
                painter
                    .cylinder(Aabb {
                        min: (step_pos - step_size + 1).with_z(bldg_base - 4 + s as i32),
                        max: (step_pos + step_size - 1).with_z(bldg_base - 2 + s as i32),
                    })
                    .fill(white.clone());
            }
            let lamp_positions = place_circular(center, (bldg_size + 1) as f32, 14);
            for (l, lamp_pos) in lamp_positions.enumerate() {
                if (RandomField::new(0).get(lamp_pos.with_z(base)) % 4) < 1 {
                    painter
                        .aabb(Aabb {
                            min: (lamp_pos - 1).with_z(bldg_base - 3 + l as i32),
                            max: (lamp_pos + 1).with_z(bldg_base - 2 + l as i32),
                        })
                        .fill(blue_broken.clone());

                    painter.sprite(
                        lamp_pos.with_z(bldg_base - 2 + l as i32),
                        SpriteKind::FireBowlGround,
                    );
                }
            }
        }
    }
}
